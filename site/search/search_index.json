{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SynthShapes","text":"<p>SynthShapes is a PyTorch toolbox for generating synthetic 3D shapes, tailored specifically for augmenting biomedical imaging datasets. It allows users to create complex, realistic shapes for use in machine learning pipelines, especially when training data is scarce or needs augmentation.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Generate a variety of 3D shapes (e.g., blobs, toroids).</li> <li>Easily customizable parameters (size, shape, intensity).</li> <li>Ready-to-go augmentation modules for biomedical image datasets (real or synth).</li> </ul>"},{"location":"#available-shapes","title":"Available Shapes","text":"<p>Although there are currently only two available shapes to choose from, they span a wide range of configurations, thanks to their jitter (and in the special case of blobs; number of lobes and sharpness). The shapes are:</p> <ul> <li>Multi-lobed blobs: Jittered blobs consisting of multiple distinct lobes, ideal for simulating biological structures such as nuclei, cells, or other kinds of miscellaneous clumps of \"stuff\".</li> <li>Toroids: Jittered toroids that are helpful for augmenting if the goal is differentiating straight, tube like structures (vessels, axons).</li> </ul>"},{"location":"quickstart/","title":"Installation","text":"<p>It is suggested that you create and activate a new mamba environment with python 3.9. You can learn how to install mamba by following the instructions provided in the Miniforge repo.</p> <pre><code>mamba create -n synthshapes python=3.9\nmamba activate synthshapes\n</code></pre> <p>Now let's install install SynthShapes from pypi! It's as easy as that!</p> <pre><code>pip install SynthShapes\n</code></pre>"},{"location":"quickstart/#usage","title":"Usage","text":"<pre><code>import torch\nimport cornucopia as cc\nimport matplotlib.pyplot as plt\nfrom SynthShapes.shapes import MultiLobeBlobAugmentation\n\n# Generate the background (or medical imaging volume)\nvolumetric_data = torch.randn((1, 64, 64, 64))\n\n# Augment the data and return the blob mask (for, perhaps, supervised segmentation)\naugmented_volumetric_data, blob_mask = MultiLobeBlobAugmentation(\n    alpha=cc.Uniform(0.5, 0.75),\n    intensity_shift=cc.Uniform(2, 20),\n    return_mask=True\n    )(volumetric_data)\n\n# Visualize one slice\nplt.imshow(augmented_volumetric_data[0, 32], cmap='gray')\nplt.show()\n</code></pre>"},{"location":"api/SynthShapes/","title":"SynthShapes","text":""},{"location":"api/SynthShapes/#SynthShapes","title":"SynthShapes","text":"<p><code>SynthShapes</code> is a primitive yet powerful PyTorch-based toolbox designed to generate synthetic 3D shapes, tailored specifically for augmenting biomedical imaging datasets. It is built to address the challenges faced in machine learning pipelines for biomedical imaging, such as limited availability of annotated data, the need for diverse training datasets, and the necessity of domain-specific augmentations.</p> MODULE DESCRIPTION <code>blending</code> <p>Tools for alpha-blending tensors.</p> <code>filters</code> <p>Kernel-based spatial filters/transformations.</p> <code>hist</code> <p>Modules to map intensity histograms to one another.</p> <code>shapes</code> <p>Augmentation layers for incorporating synthetic shapes into 3D images.</p> <code>texturizing</code> <p>Tools to apply textures to label maps.</p> <code>utils</code> <p>General-purpose utilities for comon operations.</p>"},{"location":"api/blending/","title":"SynthShapes.blending","text":""},{"location":"api/blending/#SynthShapes.blending","title":"SynthShapes.blending","text":""},{"location":"api/blending/#SynthShapes.blending--overview","title":"Overview","text":"<p>The SynthShapes.blending module offers simple tools for combining multiple shapes, textures, or regions within an image to create seamless and realistic synthetic data. This module is ideal for applications that require simple to complex image compositions.</p>"},{"location":"api/blending/#SynthShapes.blending.Blender","title":"Blender","text":"<pre><code>Blender(alpha=cc.Uniform(0.5, 5), intensity_shift=10)\n</code></pre> <p>               Bases: <code>Module</code></p> <p><code>nn.Module</code> To alpha blend two tensors according to the blending parameter <code>alpha</code>.</p> PARAMETER DESCRIPTION <code>alpha</code> <p>Blending factor or sampler.</p> <p> TYPE: <code>Sampler or float</code> DEFAULT: <code>Uniform(0.5, 5)</code> </p> <code>intensity_shift</code> <p>Intensity offset WRT mean=0, std=0 background.</p> <p> TYPE: <code>float</code> DEFAULT: <code>10</code> </p> Source code in <code>SynthShapes/blending.py</code> <pre><code>def __init__(\n    self,\n    alpha: float = cc.Uniform(0.5, 5),\n    intensity_shift: float = 10\n):\n    \"\"\"\n    [`nn.Module`][torch.nn.Module] To alpha blend two tensors according to\n    the blending parameter `alpha`.\n\n    Parameters\n    ----------\n    alpha : Sampler or float\n        Blending factor or sampler.\n    intensity_shift: Sampler or float\n        Intensity offset WRT mean=0, std=0 background.\n    \"\"\"\n    super(Blender, self).__init__()\n    self.alpha = cc.Uniform.make(make_range(0, alpha))\n    self.intensity_shift = cc.Uniform.make(make_range(0, intensity_shift))\n</code></pre>"},{"location":"api/blending/#SynthShapes.blending.Blender.forward","title":"forward","text":"<pre><code>forward(foreground, background, mask)\n</code></pre> <p>Forward pass of <code>Blender</code> to apply the blending operation and return the blended tensor.</p> PARAMETER DESCRIPTION <code>foreground</code> <p>The tensor with shapes to blend (each shape should have a unique ID).</p> <p> TYPE: <code>tensor</code> </p> <code>background</code> <p>The intensity image (tensor) to blend shapes into.</p> <p> TYPE: <code>tensor</code> </p> Source code in <code>SynthShapes/blending.py</code> <pre><code>def forward(\n    self,\n    foreground: torch.Tensor,\n    background: torch.Tensor,\n    mask: torch.Tensor\n):\n    \"\"\"\n    Forward pass of `Blender` to apply the blending operation and return\n    the blended tensor.\n\n    Parameters\n    ----------\n    foreground : tensor\n        The tensor with shapes to blend (each shape should have a unique\n        ID).\n    background : tensor\n        The intensity image (tensor) to blend shapes into.\n    \"\"\"\n    # Sample params\n    alpha = self.alpha()\n    intensity_shift = self.intensity_shift()\n    # Ensure image and shapes are both float\n    foreground = foreground.float()\n    background = background.float()\n    # Background mean=0, std=1\n    background -= background.mean()\n    background /= background.std()\n    # Foreground mean=0, std=1\n    foreground[mask] -= foreground[mask].mean()\n    foreground[mask] /= foreground[mask].std()\n    foreground[mask] += intensity_shift\n    # Perform blending operation\n    foreground[mask] = (\n        (background[mask] * (1 - alpha))\n        + (foreground[mask] * alpha)\n    )\n    foreground[~mask] = background[~mask]\n    return foreground\n</code></pre>"},{"location":"api/filters/","title":"SynthShapes.filters","text":""},{"location":"api/filters/#SynthShapes.filters","title":"SynthShapes.filters","text":""},{"location":"api/filters/#SynthShapes.filters.MinimumFilter3D","title":"MinimumFilter3D","text":"<pre><code>MinimumFilter3D(kernel_size=3)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>A module to apply a minimum filter to 3D volumes using 3x3x3 patches.</p> PARAMETER DESCRIPTION <code>kernel_size</code> <p>Size of the neighborhood from which the minimum is computed. Must be an odd number, typically 3 for a 3x3x3 filter.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>SynthShapes/filters.py</code> <pre><code>def __init__(self, kernel_size=3):\n    super().__init__()\n    self.kernel_size = kernel_size\n    self.padding = kernel_size // 2\n</code></pre>"},{"location":"api/filters/#SynthShapes.filters.MinimumFilter3D.forward","title":"forward","text":"<pre><code>forward(volume)\n</code></pre> <p>Apply the minimum filter to an input 3D volume.</p> PARAMETER DESCRIPTION <code>volume</code> <p>Input 4D tensor representing the volume. Should be of shape [batch_size, channels, depth, height, width].</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>Output 4D tensor after applying the minimum filter. Shape matches the input shape.</p> Source code in <code>SynthShapes/filters.py</code> <pre><code>def forward(self, volume):\n    \"\"\"\n    Apply the minimum filter to an input 3D volume.\n\n    Parameters\n    ----------\n    volume : torch.Tensor\n        Input 4D tensor representing the volume. Should be of shape\n        [batch_size, channels, depth, height, width].\n\n    Returns\n    -------\n    torch.Tensor\n        Output 4D tensor after applying the minimum filter. Shape matches\n        the input shape.\n    \"\"\"\n    # Reshaping tensor as needed\n    volume = ensure_5d_tensor(volume)\n\n    # Apply a max pooling with a negative sign to simulate a minimum filter\n    volume_neg = -volume\n    min_filtered = -F.max_pool3d(\n        volume_neg, kernel_size=self.kernel_size, padding=self.padding,\n        stride=1)\n\n    return min_filtered\n</code></pre>"},{"location":"api/filters/#SynthShapes.filters.GaussianSmoothing3D","title":"GaussianSmoothing3D","text":"<pre><code>GaussianSmoothing3D(kernel_size=3, sigma=1.0)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>A module to apply Gaussian smoothing to 3D volumes using 3D convolution.</p> <p>This class extends <code>nn.Module</code> to handle 3D data, applying a Gaussian smoothing filter across the input tensor using a 3D kernel.</p> PARAMETER DESCRIPTION <code>kernel_size</code> <p>Size of the Gaussian kernel. Must be an odd number, typically 3 or 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>sigma</code> <p>Standard deviation of the Gaussian kernel.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> Source code in <code>SynthShapes/filters.py</code> <pre><code>def __init__(self, kernel_size=3, sigma=1.0):\n    super().__init__()\n    self.kernel_size = kernel_size\n    self.sigma = sigma\n    self.padding = kernel_size // 2\n\n    # Create the 3D Gaussian kernel\n    self.kernel = self.create_gaussian_kernel(kernel_size, sigma)\n</code></pre>"},{"location":"api/filters/#SynthShapes.filters.GaussianSmoothing3D.forward","title":"forward","text":"<pre><code>forward(volume)\n</code></pre> <p>Apply the Gaussian smoothing filter to an input 3D volume.</p> PARAMETER DESCRIPTION <code>volume</code> <p>Input 4D tensor representing the volume. Should be of shape [batch_size, channels, depth, height, width].</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>Output 4D tensor after applying Gaussian smoothing. Shape matches  the input shape.</p> Source code in <code>SynthShapes/filters.py</code> <pre><code>def forward(self, volume):\n    \"\"\"\n    Apply the Gaussian smoothing filter to an input 3D volume.\n\n    Parameters\n    ----------\n    volume : torch.Tensor\n        Input 4D tensor representing the volume. Should be of shape\n        [batch_size, channels, depth, height, width].\n\n    Returns\n    -------\n    torch.Tensor\n        Output 4D tensor after applying Gaussian smoothing. Shape matches \n        the input shape.\n    \"\"\"\n    # Reshaping tensor as needed\n    volume = ensure_5d_tensor(volume)\n\n    # Apply Gaussian filter using 3D convolution\n    padding = (self.padding, self.padding, self.padding, self.padding,\n               self.padding, self.padding)\n    padded_volume = F.pad(volume, padding, mode='reflect')\n    volume = F.conv3d(padded_volume, self.kernel, padding=0,\n                      groups=volume.shape[1])\n    return volume\n</code></pre>"},{"location":"api/filters/#SynthShapes.filters.GaussianSmoothing3D.create_gaussian_kernel","title":"create_gaussian_kernel","text":"<pre><code>create_gaussian_kernel(kernel_size, sigma)\n</code></pre> <p>Create the 3D Gaussian kernel.</p> PARAMETER DESCRIPTION <code>kernel_size</code> <p>Size of Gaussian kernel.</p> <p> TYPE: <code>int</code> </p> <code>sigma</code> <p>Standard deviation of the Gaussian kernel.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>5D tensor representing the 3D Gaussian kernel for use in conv3d.</p> Source code in <code>SynthShapes/filters.py</code> <pre><code>def create_gaussian_kernel(self, kernel_size, sigma):\n    \"\"\"\n    Create the 3D Gaussian kernel.\n\n    Parameters\n    ----------\n    kernel_size : int\n        Size of Gaussian kernel.\n    sigma : float\n        Standard deviation of the Gaussian kernel.\n\n    Returns\n    -------\n    torch.Tensor\n        5D tensor representing the 3D Gaussian kernel for use in conv3d.\n    \"\"\"\n    # Create a coordinate grid centered at zero\n    coords = torch.arange(kernel_size).float() - (kernel_size - 1) / 2\n    grid = torch.stack(torch.meshgrid(coords, coords, coords), -1)\n\n    # Calculate the Gaussian function\n    kernel = torch.exp(-((grid ** 2).sum(-1) / (2 * sigma ** 2))).cuda()\n\n    # Normalize the kernel so that the sum of all elements is 1\n    kernel = kernel / kernel.sum()\n\n    # Reshape to 5D tensor for conv3d\n    kernel = kernel.view(1, 1, kernel_size, kernel_size, kernel_size)\n    kernel = kernel.repeat(1, 1, 1, 1, 1)\n\n    return kernel\n</code></pre>"},{"location":"api/hist/","title":"SynthShapes.hist","text":""},{"location":"api/hist/#SynthShapes.hist","title":"SynthShapes.hist","text":""},{"location":"api/hist/#SynthShapes.hist.MatchHistogram","title":"MatchHistogram","text":"<pre><code>MatchHistogram(mean=0.0, std=0.2, num_bins=256)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Histogram Matching Module to map the intensity values of an image to follow a normal distribution.</p> PARAMETER DESCRIPTION <code>mean</code> <p>Mean of the normal distribution, by default 0.0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>std</code> <p>Standard deviation of the normal distribution, by default 0.2.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.2</code> </p> <code>num_bins</code> <p>Number of bins for histogram, by default 256.</p> <p> TYPE: <code>int</code> DEFAULT: <code>256</code> </p> Source code in <code>SynthShapes/hist.py</code> <pre><code>def __init__(self, mean=0.0, std=0.2, num_bins=256):\n    \"\"\"\n    Histogram Matching Module to map the intensity values of an image to\n    follow a normal distribution.\n\n    Parameters\n    ----------\n    mean : float, optional\n        Mean of the normal distribution, by default 0.0.\n    std : float, optional\n        Standard deviation of the normal distribution, by default 0.2.\n    num_bins : int, optional\n        Number of bins for histogram, by default 256.\n    \"\"\"\n    super(MatchHistogram, self).__init__()\n    self.mean = mean\n    self.std = std\n    self.num_bins = num_bins\n</code></pre>"},{"location":"api/hist/#SynthShapes.hist.MatchHistogram.calculate_cdf","title":"calculate_cdf","text":"<pre><code>calculate_cdf(hist)\n</code></pre> <p>Calculate the cumulative distribution function (CDF) for a histogram.</p> Source code in <code>SynthShapes/hist.py</code> <pre><code>def calculate_cdf(self, hist):\n    \"\"\"Calculate the cumulative distribution function (CDF) for a\n    histogram.\"\"\"\n    cdf = hist.cumsum(0)\n    cdf_normalized = cdf / cdf[-1]\n    return cdf_normalized\n</code></pre>"},{"location":"api/hist/#SynthShapes.hist.MatchHistogram.forward","title":"forward","text":"<pre><code>forward(source)\n</code></pre> <p>Forward pass to perform histogram matching.</p> PARAMETER DESCRIPTION <code>source</code> <p>Source image (HxW), normalized between -1 and 1.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>matched</code> <p>The transformed source image with histogram matching a normal distribution.</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>SynthShapes/hist.py</code> <pre><code>def forward(self, source):\n    \"\"\"\n    Forward pass to perform histogram matching.\n\n    Parameters\n    ----------\n    source : torch.Tensor\n        Source image (HxW), normalized between -1 and 1.\n\n    Returns\n    -------\n    matched : torch.Tensor\n        The transformed source image with histogram matching a normal\n        distribution.\n    \"\"\"\n    device = source.device\n\n    # Normalize the source image to the range [0, 255] for histogram\n    # computation\n    source_normalized = ((source + 1) / 2 * 255).clamp(0, 255).long()\n\n    # Compute the histogram and CDF of the source image\n    src_hist = torch.histc(source_normalized.float(),\n                           bins=self.num_bins, min=0, max=255).to(device)\n    src_cdf = self.calculate_cdf(src_hist)\n\n    # Create the normal distribution CDF\n    normal_values = torch.linspace(-1, 1, self.num_bins, device=device)\n    normal_cdf = torch.distributions.Normal(\n        self.mean, self.std).cdf(normal_values)\n    normal_cdf = normal_cdf / normal_cdf[-1]  # Normalize to range [0, 1]\n\n    # Create a lookup table to map the pixel values\n    lookup_table = torch.zeros(self.num_bins, device=device)\n    for src_pixel in range(self.num_bins):\n        normal_pixel = torch.searchsorted(normal_cdf, src_cdf[src_pixel])\n        lookup_table[src_pixel] = normal_pixel\n\n    # Apply the lookup table to the source image\n    source_flat = source_normalized.flatten().long()\n    matched_flat = lookup_table[source_flat]\n    matched = matched_flat.view(source.shape).float()\n\n    # Convert matched image back to the range [-1, 1]\n    matched = matched / (self.num_bins - 1) * 2 - 1\n\n    return matched\n</code></pre>"},{"location":"api/shapes/","title":"SynthShapes.shapes","text":""},{"location":"api/shapes/#SynthShapes.shapes","title":"SynthShapes.shapes","text":""},{"location":"api/shapes/#SynthShapes.shapes--overview","title":"Overview","text":"<p>The <code>SynthShapes.shapes</code> module provides a comprehensive toolkit for generating geometric shapes and patterns, tailored for synthetic image generation in biomedical imaging and beyond. This module supports a variety of 2D and 3D shapes with customizable parameters, enabling users to create realistic and diverse datasets for machine learning and computer vision applications.</p>"},{"location":"api/shapes/#SynthShapes.shapes--features","title":"Features","text":"<ul> <li> <p>Shape Generators: Includes predefined methods for creating common geometric shapes like spheres, stars, toroids, rectangles, spheres, and cubes.</p> </li> <li> <p>Customizability: Allows fine-tuning of parameters such as size, position, orientation, and intensity for each shape.</p> </li> <li> <p>Multi-shape Compositions: Supports combining multiple shapes into a single image for more complex synthetic data.</p> </li> <li> <p>Label Maps: Since texturized data is synthesized from semantic label maps, one-hot encoded labels are easily retreived for semantic segmentation workflows.</p> </li> </ul>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobConfig","title":"MultiLobedBlobConfig  <code>dataclass</code>","text":"<pre><code>MultiLobedBlobConfig(\n    axis_length=cc.RandInt.make(\n        make_range(2, cc.RandInt(3, 6))\n    ),\n    blob_density=cc.Fixed(0.05),\n    n_blobs=cc.RandInt(10, 25),\n    n_lobes=cc.RandInt(1, 5),\n    sharpness=cc.Uniform(1, 3),\n    jitter=cc.Uniform(0, 0.5),\n    return_mask=True,\n    device=\"cuda\",\n)\n</code></pre> <p>Configuration container for MultiLobedBlobBase.</p> ATTRIBUTE DESCRIPTION <code>shape</code> <p>Size of the 3D volume (assumed to be cubic). Default is [128, 128, 128].</p> <p> TYPE: <code>list of int, optional</code> </p> <code>axis_length</code> <p>Range of the lengths for any given axis of the blob. Default is RandInt(3, 6).</p> <p> TYPE: <code>(Sampler, optional)</code> </p> <code>blob_density</code> <p>Density of blobs in the volume. Default is Fixed(0.05).</p> <p> TYPE: <code>(Sampler, optional)</code> </p> <code>n_blobs</code> <p>Maximum number of multi-lobed blobs. Default is RandInt(10, 25).</p> <p> TYPE: <code>(Sampler, optional)</code> </p> <code>n_lobes</code> <p>Sampler range for the number of lobes per blob. Default is RandInt(1, 5).</p> <p> TYPE: <code>(Sampler, optional)</code> </p> <code>sharpness</code> <p>Upper bound for factor controlling the squareness of the blobs. Note: +5 = mostly squares, 2 &lt; sharpness &lt; 4 = spheres, sharpness &lt; 2 = stars. Default is Uniform(1, 3).</p> <p> TYPE: <code>(Sampler, optional)</code> </p> <code>jitter</code> <p>Maximum amount of jitter/raggedness to apply to the shape. Default is Uniform(0, 0.5).</p> <p> TYPE: <code>(Sampler, optional)</code> </p> <code>device</code> <p>Device to perform computations on. Default is 'cuda'.</p> <p> TYPE: <code>(str, optional)</code> </p>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobBase","title":"MultiLobedBlobBase","text":"<pre><code>MultiLobedBlobBase(config=MultiLobedBlobConfig)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base module for multi-lobed blob operations.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration container for blob parameters.</p> <p> TYPE: <code>MultiLobedBlobConfig</code> DEFAULT: <code>MultiLobedBlobConfig</code> </p> <p>Base module for multi-lobed blob operations.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration container for blob parameters.</p> <p> TYPE: <code>MultiLobedBlobConfig</code> DEFAULT: <code>MultiLobedBlobConfig</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def __init__(self, config: MultiLobedBlobConfig = MultiLobedBlobConfig):\n    \"\"\"\n    Base module for multi-lobed blob operations.\n\n    Parameters\n    ----------\n    config : MultiLobedBlobConfig\n        Configuration container for blob parameters.\n    \"\"\"\n    super(MultiLobedBlobBase, self).__init__()\n    self.config = config\n    self.current_label = 1\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobBase.sample_axis_lengths","title":"sample_axis_lengths","text":"<pre><code>sample_axis_lengths()\n</code></pre> <p>Sample the axis lengths for all dimensions of a blob.</p> RETURNS DESCRIPTION <code>axis_lengths</code> <p>Axis lengths of the blob (D, H, W).</p> <p> TYPE: <code>Tensor[int, int, int]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def sample_axis_lengths(self):\n    \"\"\"\n    Sample the axis lengths for all dimensions of a blob.\n\n    Returns\n    -------\n    axis_lengths : torch.Tensor[int, int, int]\n        Axis lengths of the blob (D, H, W).\n    \"\"\"\n    axis_lengths = torch.tensor(\n        [\n            self.config.axis_length(),\n            self.config.axis_length(),\n            self.config.axis_length()\n        ]\n    )\n    return axis_lengths\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobBase.sample_centroid_coords","title":"sample_centroid_coords","text":"<pre><code>sample_centroid_coords(axis_lengths)\n</code></pre> <p>Sample the coordinates of the blob's centroid.</p> PARAMETER DESCRIPTION <code>axis_lengths</code> <p>Axis lengths of the blob (depth, height, width).</p> <p> TYPE: <code>Tensor[int, int, int]</code> </p> RETURNS DESCRIPTION <code>centroid_coords</code> <p>Coordinates of the centroid (depth, height, width).</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def sample_centroid_coords(self, axis_lengths: torch.Tensor):\n    \"\"\"\n    Sample the coordinates of the blob's centroid.\n\n    Parameters\n    ----------\n    axis_lengths : torch.Tensor[int, int, int]\n        Axis lengths of the blob (depth, height, width).\n\n    Returns\n    -------\n    centroid_coords : tuple[int, int, int]\n        Coordinates of the centroid (depth, height, width).\n    \"\"\"\n    centroid_coords = (\n        torch.randint(\n            axis_lengths[0],\n            self.shape[0] - axis_lengths[0],\n            (1,), device=self.config.device).item(),\n        torch.randint(\n            axis_lengths[1],\n            self.shape[1] - axis_lengths[1],\n            (1,), device=self.config.device).item(),\n        torch.randint(\n            axis_lengths[2],\n            self.shape[2] - axis_lengths[2],\n            (1,), device=self.config.device).item()\n        )\n    return centroid_coords\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobBase.check_overlap","title":"check_overlap","text":"<pre><code>check_overlap(\n    axis_lengths, centroid_coords, axes_list=[], centers=[]\n)\n</code></pre> <p>Check if the newly sampled blob overlaps with existing blobs.</p> <p>This function computes the euclidean distance between the centroid of the new blobs and those of the existing blobs. The distance is compared to the sum of the largest axes of the blob, to ensure it is larger, ensuring no overlap exists between the blobs.</p> PARAMETER DESCRIPTION <code>axis_lengths</code> <p>Axis lengths of the new blob (depth, height, width).</p> <p> TYPE: <code>Tensor[int, int, int]</code> </p> <code>centroid_coords</code> <p>Coordinates of the new blob's centroid (depth, height, width).</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>axes_list</code> <p>A list of tuples representing the lengths of each axis for all blobs.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[]</code> </p> <code>centroid_coords</code> <p>A list of tuples representing the coordinates of the centroid of each existing blob.</p> <p> TYPE: <code>list</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def check_overlap(self, axis_lengths: torch.Tensor, centroid_coords: tuple,\n                  axes_list: list = [], centers: list = []):\n    \"\"\"\n    Check if the newly sampled blob overlaps with existing blobs.\n\n    This function computes the euclidean distance between the centroid of\n    the new blobs and those of the existing blobs. The distance is\n    compared to the sum of the largest axes of the blob, to ensure it is\n    larger, ensuring no overlap exists between the blobs.\n\n    Parameters\n    ----------\n    axis_lengths : torch.Tensor[int, int, int]\n        Axis lengths of the new blob (depth, height, width).\n    centroid_coords : tuple[int, int, int]\n        Coordinates of the new blob's centroid (depth, height, width).\n    axes_list : list\n        A list of tuples representing the lengths of each axis for all\n        blobs.\n    centroid_coords : list\n        A list of tuples representing the coordinates of the centroid of\n        each existing blob.\n    \"\"\"\n    overlap_exists = False\n    # Iterate through all center coordinate and axis length pairs that have\n    # been sampled\n    for c, a in zip(centers, axes_list):\n        # Calculate euclidean distance between the centroid of an existing\n        # blob and this current blob.\n        distance = torch.sqrt(\n            torch.tensor((centroid_coords[0] - c[0]) ** 2\n                         + (centroid_coords[1] - c[1]) ** 2\n                         + (centroid_coords[2] - c[2]) ** 2,\n                         device=self.config.device)\n        )\n        # Ensure the euclidean distance between centroids is larger than\n        # the sum of the largest axes of both blobs, ensuring no overlap.\n        if distance &lt; max(a) + max(axis_lengths):\n            # If the distance is less than sum of largest axes, overlap yes\n            overlap_exists = True\n            break\n    return overlap_exists\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobBase.sample_nonoverlapping_geometries","title":"sample_nonoverlapping_geometries","text":"<pre><code>sample_nonoverlapping_geometries()\n</code></pre> <p>Sample nonoverlapping bounding boxes by generating list of centers and axis lengths.</p> <p>This method creates two lists (center coordinates and axes lengths) that will be used to describe the bounding boxes for each blob to be sampled.</p> RETURNS DESCRIPTION <code>centers</code> <p>List of tuples representing the centroid coordinates for each bounding box (centroid_coords)</p> <p> TYPE: <code>list</code> </p> <code>axes_list</code> <p>List of tuples representing the length of each 3 axes for each geometry</p> <p> TYPE: <code>list</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def sample_nonoverlapping_geometries(self):\n    \"\"\"\n    Sample nonoverlapping bounding boxes by generating list of centers and\n    axis lengths.\n\n    This method creates two lists (center coordinates and axes lengths)\n    that will be used to describe the bounding boxes for each blob to be\n    sampled.\n\n    Returns\n    -------\n    centers : list\n        List of tuples representing the centroid coordinates for each\n        bounding box (centroid_coords)\n    axes_list : list\n        List of tuples representing the length of each 3 axes for each\n        geometry\n    \"\"\"\n    # List of center coordinates for existing blobs\n    centers = []\n    # List of axes lengths for existing blobs\n    axes_list = []\n\n    # Iterate until we get self.n_blobs blobs.\n    while len(centers) &lt; self.n_blobs():\n        # Sample a tuple of axis lengths.\n        axis_lengths = self.sample_axis_lengths()\n        # Sample a tuple of centroid coordinates.\n        centroid_coords = self.sample_centroid_coords(axis_lengths)\n        # Check if overlap exists between the newly sampled bounding box\n        # and the existing ones.\n        overlap_exists = self.check_overlap(axis_lengths, centroid_coords,\n                                            axes_list, centers)\n        if not overlap_exists:\n            centers.append(centroid_coords)\n            axes_list.append(axis_lengths.tolist())\n\n    return centers, axes_list\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobBase.make_shapes","title":"make_shapes","text":"<pre><code>make_shapes(shape)\n</code></pre> <p>Make shape labels.</p> RETURNS DESCRIPTION <code>imprint_tensor</code> <p>Blobs with unique integer labels.</p> <p> TYPE: <code>Tensor[int]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def make_shapes(self, shape):\n    \"\"\"\n    Make shape labels.\n\n    Returns\n    -------\n    imprint_tensor : torch.Tensor[int]\n        Blobs with unique integer labels.\n    \"\"\"\n    self.shape = shape\n    self.max_blobs = self.config.blob_density() * (\n        torch.prod(torch.tensor(self.shape).cuda(), 0)**0.5\n        )\n    self.max_blobs = torch.ceil(self.max_blobs).item()\n    self.n_blobs = cc.RandInt(\n        self.max_blobs//2, self.max_blobs\n        )\n\n    # self.depth, self.height, self.width = self.shape\n    self.imprint_tensor = torch.zeros(\n        self.shape,\n        dtype=torch.float32,\n        device=self.config.device\n        )\n\n    centers, axes_list = self.sample_nonoverlapping_geometries()\n    for center, axes in zip(centers, axes_list):\n        # Make tensor for blob (and all lobes)\n        lobe_tensor = torch.zeros(\n            shape, dtype=torch.float32, device=self.config.device)\n        # Make lobes one by one\n        for _ in range(self.config.n_lobes()):\n            lobe_center_shift = torch.randint(\n                -axes[0]+1, axes[0]-1, (3,), device=self.config.device)\n            shifted_center = (center[0] + lobe_center_shift[0],\n                              center[1] + lobe_center_shift[1],\n                              center[2] + lobe_center_shift[2])\n            shifted_meshgrid = self._meshgrid_origin_at_centroid(\n                shifted_center)\n            lobe_prob = self._make_lobe_prob(shifted_meshgrid, axes)\n            lobe = self._make_lobe_from_prob(lobe_prob)\n            lobe_tensor += lobe\n        # Add all lobes to imprint tensor\n        self.imprint_tensor[lobe_tensor &gt; 0] = lobe_tensor[lobe_tensor &gt; 0]\n\n    return self.imprint_tensor.unsqueeze(0)\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobSampler","title":"MultiLobedBlobSampler","text":"<pre><code>MultiLobedBlobSampler(config=MultiLobedBlobConfig)\n</code></pre> <p>               Bases: <code>MultiLobedBlobBase</code></p> <p>PyTorch module to sample multi-lobed blob labels in a 3D tensor.</p> <p>Inherits from MultiLobedBlobBase.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration container for blob parameters.</p> <p> TYPE: <code>MultiLobedBlobConfig</code> DEFAULT: <code>MultiLobedBlobConfig</code> </p> <p>PyTorch module to sample multi-lobed blob labels in a 3D tensor.</p> <p>Inherits from MultiLobedBlobBase.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration container for blob parameters.</p> <p> TYPE: <code>MultiLobedBlobConfig</code> DEFAULT: <code>MultiLobedBlobConfig</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def __init__(self, config: MultiLobedBlobConfig = MultiLobedBlobConfig):\n    \"\"\"\n    PyTorch module to sample multi-lobed blob labels in a 3D tensor.\n\n    Inherits from MultiLobedBlobBase.\n\n    Parameters\n    ----------\n    config : MultiLobedBlobConfig\n        Configuration container for blob parameters.\n    \"\"\"\n    super(MultiLobedBlobBase, self).__init__()\n    self.config = config\n    self.current_label = 1\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobedBlobSampler.forward","title":"forward","text":"<pre><code>forward(shape)\n</code></pre> <p>Apply blob-sampling operation.</p> RETURNS DESCRIPTION <code>shapes</code> <p>Blobs with unique integer labels.</p> <p> TYPE: <code>tensor[int]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def forward(self, shape):\n    \"\"\"\n    Apply blob-sampling operation.\n\n    Returns\n    -------\n    shapes : torch.tensor[int]\n        Blobs with unique integer labels.\n    \"\"\"\n    blob_labels = self.make_shapes(shape)\n    if self.config.return_mask:\n        blob_mask = (blob_labels &gt; 0).bool().to(self.config.device)\n        return blob_labels, blob_mask\n    else:\n        return blob_labels\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobeBlobAugmentation","title":"MultiLobeBlobAugmentation","text":"<pre><code>MultiLobeBlobAugmentation(\n    config=MultiLobedBlobConfig,\n    alpha=cc.Uniform(0.25, 0.75),\n    intensity_shift=cc.Uniform(10, 20),\n    augmentation=None,\n    device=\"cuda\",\n)\n</code></pre> <p>               Bases: <code>MultiLobedBlobBase</code></p> <p>PyTorch module to augment 3D data (C, D, H, W) by sampling and alpha-blending multi-lobed blobs.</p> <p>Inherits from MultiLobedBlobBase.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration container for blob parameters.</p> <p> TYPE: <code>MultiLobedBlobConfig</code> DEFAULT: <code>MultiLobedBlobConfig</code> </p> <p>PyTorch module to augment 3D data (C, D, H, W) by sampling and alpha-blending multi-lobed blobs.</p> <p>MultiLobedBlobBase.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration container for blob parameters.</p> <p> TYPE: <code>MultiLobedBlobConfig</code> DEFAULT: <code>MultiLobedBlobConfig</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def __init__(self,\n             config: MultiLobedBlobConfig = MultiLobedBlobConfig,\n             alpha: Sampler = cc.Uniform(0.25, 0.75),\n             intensity_shift: float = cc.Uniform(10, 20),\n             augmentation=None,\n             device='cuda'):\n    \"\"\"\n    PyTorch module to augment 3D data (C, D, H, W) by sampling and\n    alpha-blending multi-lobed blobs.\n\n    MultiLobedBlobBase.\n\n    Parameters\n    ----------\n    config : MultiLobedBlobConfig\n        Configuration container for blob parameters.\n    \"\"\"\n    super(MultiLobedBlobBase, self).__init__()\n    self.config = config\n    self.current_label = 1\n    if augmentation is None:\n        self.augmentation = cc.RandomGaussianMixtureTransform(mu=0)\n    else:\n        self.augmentation = augmentation\n\n    self.alpha = cc.Uniform.make(make_range(0.5, alpha))\n    self.intensity_shift = cc.Uniform.make(make_range(0, intensity_shift))\n    self.blender = Blender(\n        alpha=self.alpha,\n        intensity_shift=self.intensity_shift\n    )\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.MultiLobeBlobAugmentation.forward","title":"forward","text":"<pre><code>forward(background_intensities)\n</code></pre> <p>Apply blob augmentation to input tensor.</p> PARAMETER DESCRIPTION <code>incoming_tensor</code> <p>Background tensor to augment of shape (C, D, H, W)</p> <p> TYPE: <code>Tensor[float]</code> </p> RETURNS DESCRIPTION <code>blended_blobs</code> <p>Blobs alpha-blended into background.</p> <p> TYPE: <code>Tensor[float]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def forward(self, background_intensities: torch.Tensor):\n    \"\"\"\n    Apply blob augmentation to input tensor.\n\n    Parameters\n    ----------\n    incoming_tensor : torch.Tensor[float]\n        Background tensor to augment of shape (C, D, H, W)\n\n    Returns\n    -------\n    blended_blobs : torch.Tensor[float]\n        Blobs alpha-blended into background.\n    \"\"\"\n    shape = background_intensities.squeeze().shape\n    incoming_shape_labels = self.make_shapes(shape)\n    incoming_shape_mask = (incoming_shape_labels &gt; 0).bool().to(\n        self.config.device\n        )\n    if self.augmentation:\n        incoming_shape_labels = self.augmentation(incoming_shape_labels)\n        incoming_shape_labels[~incoming_shape_mask] = 0\n\n    blended = self.blender(\n        incoming_shape_labels.to(self.config.device),\n        background_intensities.to(self.config.device),\n        incoming_shape_mask.to(self.config.device)\n    )\n\n    if self.config.return_mask:\n        return blended, incoming_shape_mask\n    else:\n        return blended\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobBase","title":"TorusBlobBase","text":"<pre><code>TorusBlobBase(\n    major_radius_range=[10, 20],\n    minor_radius_range=[3, 6],\n    n_blobs=cc.RandInt(10, 25),\n    jitter=cc.Uniform(0, 0.5),\n    device=\"cuda\",\n    shape=128,\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Base PyTorch module for torus blob operations.</p> PARAMETER DESCRIPTION <code>major_radius_range</code> <p>Range of lengths for the major radius of the torus. Default is [10, 20]</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[10, 20]</code> </p> <code>minor_radius_range</code> <p>Range of lengths for the minor radius of the torus. Default is [3, 6].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[3, 6]</code> </p> <code>n_blobs</code> <p>Maximum number of tori to generate. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RandInt(10, 25)</code> </p> <code>jitter</code> <p>Maximum amount of jitter to apply to the shape. Default is 0.5.</p> <p> TYPE: <code>float</code> DEFAULT: <code>Uniform(0, 0.5)</code> </p> <code>device</code> <p>Device to run the tensor operations ('cuda' or 'cpu'). Default is 'cuda'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cuda'</code> </p> <code>shape</code> <p>Size of the 3D volume (assumed to be cubic). Default is 128.</p> <p> TYPE: <code>int</code> DEFAULT: <code>128</code> </p> <p>Base PyTorch module for torus blob operations.</p> PARAMETER DESCRIPTION <code>major_radius_range</code> <p>Range of lengths for the major radius of the torus. Default is [10, 20]</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[10, 20]</code> </p> <code>minor_radius_range</code> <p>Range of lengths for the minor radius of the torus. Default is [3, 6].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[3, 6]</code> </p> <code>n_blobs</code> <p>Maximum number of tori to generate. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RandInt(10, 25)</code> </p> <code>jitter</code> <p>Maximum amount of jitter to apply to the shape. Default is 0.5.</p> <p> TYPE: <code>float</code> DEFAULT: <code>Uniform(0, 0.5)</code> </p> <code>device</code> <p>Device to run the tensor operations ('cuda' or 'cpu'). Default is 'cuda'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cuda'</code> </p> <code>shape</code> <p>Size of the 3D volume (assumed to be cubic). Default is 128.</p> <p> TYPE: <code>int</code> DEFAULT: <code>128</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def __init__(self, major_radius_range=[10, 20], minor_radius_range=[3, 6],\n             n_blobs: Sampler = cc.RandInt(10, 25),\n             jitter: Sampler = cc.Uniform(0, 0.5),\n             device='cuda', shape=128):\n    \"\"\"\n    Base PyTorch module for torus blob operations.\n\n    Parameters\n    ----------\n    major_radius_range : list of int, optional\n        Range of lengths for the major radius of the torus. Default is\n        [10, 20]\n    minor_radius_range : list of int, optional\n        Range of lengths for the minor radius of the torus. Default is\n        [3, 6].\n    n_blobs : int, optional\n        Maximum number of tori to generate. Default is 10.\n    jitter : float, optional\n        Maximum amount of jitter to apply to the shape. Default is 0.5.\n    device : str, optional\n        Device to run the tensor operations ('cuda' or 'cpu'). Default is\n        'cuda'.\n    shape : int, optional\n        Size of the 3D volume (assumed to be cubic). Default is 128.\n    \"\"\"\n    super(TorusBlobBase, self).__init__()\n    self.major_radius_range = major_radius_range\n    self.minor_radius_range = minor_radius_range\n    self.jitter = cc.Uniform.make(make_range(0, jitter))\n    self.device = device\n    self.shape = [shape, shape, shape]\n    self.depth, self.height, self.width = self.shape\n    self.n_blobs = cc.RandInt.make(make_range(1, n_blobs))\n    self.imprint_tensor = torch.zeros(self.shape, dtype=torch.float32,\n                                      device=self.device)\n    self.current_label = 1\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobBase.sample_radii","title":"sample_radii","text":"<pre><code>sample_radii()\n</code></pre> <p>Sample the major and minor axes radii.</p> RETURNS DESCRIPTION <code>major_radius</code> <p>The magnitude of the radius of the larger axis.</p> <p> TYPE: <code>float</code> </p> <code>minor_radius</code> <p>The magnitude of the radius of the smaller axis.</p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def sample_radii(self):\n    \"\"\"\n    Sample the major and minor axes radii.\n\n    Returns\n    -------\n    major_radius : float\n        The magnitude of the radius of the larger axis.\n    minor_radius\n        The magnitude of the radius of the smaller axis.\n    \"\"\"\n    major_radius = torch.randint(\n        self.major_radius_range[0],\n        self.major_radius_range[1] + 1,\n        (1,),\n        device=self.device).item()\n    minor_radius = torch.randint(\n        self.minor_radius_range[0],\n        self.minor_radius_range[1] + 1,\n        (1,),\n        device=self.device).item()\n    return major_radius, minor_radius\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobBase.sample_centroid_coords","title":"sample_centroid_coords","text":"<pre><code>sample_centroid_coords(major_radius)\n</code></pre> <p>Sample the coordinates of the centroid.</p> RETURNS DESCRIPTION <code>centroid_coords</code> <p>Coordinates of the centroid (depth, height, width).</p> <p> TYPE: <code>tuple</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def sample_centroid_coords(self, major_radius):\n    \"\"\"\n    Sample the coordinates of the centroid.\n\n    Returns\n    -------\n    centroid_coords : tuple\n        Coordinates of the centroid (depth, height, width).\n    \"\"\"\n    centroid_coords = (\n        torch.randint(\n            major_radius,\n            self.depth - major_radius,\n            (1,), device=self.device).item(),\n        torch.randint(\n            major_radius,\n            self.height - major_radius,\n            (1,), device=self.device).item(),\n        torch.randint(\n            major_radius,\n            self.width - major_radius,\n            (1,), device=self.device).item()\n        )\n    return centroid_coords\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobBase.check_overlap","title":"check_overlap","text":"<pre><code>check_overlap(\n    major_radius, centroid_coords, radii_list=[], centers=[]\n)\n</code></pre> <p>Check if a newly sampled blob overlaps with existing blobs.</p> <p>This function computes the euclidean distance between the centroid of a newly sampled blob, and the centroids of previously sampled blobs. It then checks if the distance is less than the sum of the radii, indicating an overlap between blobs.</p> PARAMETER DESCRIPTION <code>major_radius</code> <p>The radius of the largest dimension of the newly sampled blob.</p> <p> TYPE: <code>float</code> </p> <code>centroid_coords</code> <p>Coordinates of the centroid (depth, height, width).</p> <p> TYPE: <code>tuple</code> </p> <code>radii_list</code> <p>A list of tuples of the radii belonging to blobs that have already been sampled.</p> <p> TYPE: <code>list[float]</code> DEFAULT: <code>[]</code> </p> <code>centers</code> <p>A list of tuple of the centers belonging to blobs that have already been sampled.</p> <p> TYPE: <code>list[float]</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>overlap_exists</code> <p>Whether overlap exists.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def check_overlap(self, major_radius: float, centroid_coords: tuple,\n                  radii_list: list = [], centers: list = []):\n    \"\"\"\n    Check if a newly sampled blob overlaps with existing blobs.\n\n    This function computes the euclidean distance between the centroid of\n    a newly sampled blob, and the centroids of previously sampled blobs. It\n    then checks if the distance is less than the sum of the radii,\n    indicating an overlap between blobs.\n\n    Parameters\n    ----------\n    major_radius : float\n        The radius of the largest dimension of the newly sampled blob.\n    centroid_coords : tuple\n        Coordinates of the centroid (depth, height, width).\n    radii_list : list[float]\n        A list of tuples of the radii belonging to blobs that have already\n        been sampled.\n    centers : list[float]\n        A list of tuple of the centers belonging to blobs that have already\n        been sampled.\n\n    Returns\n    -------\n    overlap_exists : bool\n        Whether overlap exists.\n    \"\"\"\n    overlap_exists = False\n    # Iterate through the centers and radii of all blobs that have been\n    # sampled\n    for c, r in zip(centers, radii_list):\n        # Calculate euclidean distance between the centroids of the\n        # current and existing blobs\n        distance = torch.sqrt(\n            torch.tensor(\n                (centroid_coords[0] - c[0]) ** 2\n                + (centroid_coords[1] - c[1]) ** 2\n                + (centroid_coords[2] - c[2]) ** 2,\n                device=self.device)\n                )\n        # Compare euclidean distance between centroids to the sum of the\n        # maximum radius of the existing blob and the max radius this blob.\n        if distance &lt; r[0] + major_radius:\n            # If the distance is less than the sum of radii, overlap exists\n            overlap_exists = True\n            break\n    return overlap_exists\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobSampler","title":"TorusBlobSampler","text":"<pre><code>TorusBlobSampler(\n    major_radius_range=[10, 20],\n    minor_radius_range=[3, 6],\n    n_blobs=cc.RandInt(10, 25),\n    jitter=cc.Uniform(0, 0.5),\n    device=\"cuda\",\n    shape=128,\n    return_mask=True,\n)\n</code></pre> <p>               Bases: <code>TorusBlobBase</code></p> <p>PyTorch module to sample torus blob labels in a 3D tensor.</p> <p>Inherits from TorusBlobBase.</p> PARAMETER DESCRIPTION <code>major_radius_range</code> <p>Range of lengths for the major radius of the torus. Default is [10, 20].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[10, 20]</code> </p> <code>minor_radius_range</code> <p>Range of lengths for the minor radius of the torus. Default is [3, 6].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[3, 6]</code> </p> <code>n_blobs</code> <p>Maximum number of tori to generate. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RandInt(10, 25)</code> </p> <code>jitter</code> <p>Maximum amount of jitter to apply to the shape. Default is 0.5.</p> <p> TYPE: <code>float</code> DEFAULT: <code>Uniform(0, 0.5)</code> </p> <code>device</code> <p>Device to run the tensor operations ('cuda' or 'cpu'). Default is 'cuda'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cuda'</code> </p> <code>shape</code> <p>Size of the 3D volume (assumed to be cubic). Default is 128.</p> <p> TYPE: <code>int</code> DEFAULT: <code>128</code> </p> <p>PyTorch module to sample torus blob labels in a 3D tensor.</p> <p>Inherits from TorusBlobBase.</p> PARAMETER DESCRIPTION <code>major_radius_range</code> <p>Range of lengths for the major radius of the torus. Default is [10, 20].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[10, 20]</code> </p> <code>minor_radius_range</code> <p>Range of lengths for the minor radius of the torus. Default is [3, 6].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[3, 6]</code> </p> <code>n_blobs</code> <p>Maximum number of tori to generate. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RandInt(10, 25)</code> </p> <code>jitter</code> <p>Maximum amount of jitter to apply to the shape. Default is 0.5.</p> <p> TYPE: <code>float</code> DEFAULT: <code>Uniform(0, 0.5)</code> </p> <code>device</code> <p>Device to run the tensor operations ('cuda' or 'cpu'). Default is 'cuda'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cuda'</code> </p> <code>shape</code> <p>Size of the 3D volume (assumed to be cubic). Default is 128.</p> <p> TYPE: <code>int</code> DEFAULT: <code>128</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def __init__(self, major_radius_range=[10, 20], minor_radius_range=[3, 6],\n             n_blobs: Sampler = cc.RandInt(10, 25),\n             jitter: Sampler = cc.Uniform(0, 0.5),\n             device: str = 'cuda', shape: int = 128,\n             return_mask: bool = True\n             ):\n    \"\"\"\n    PyTorch module to sample torus blob labels in a 3D tensor.\n\n    Inherits from TorusBlobBase.\n\n    Parameters\n    ----------\n    major_radius_range : list of int, optional\n        Range of lengths for the major radius of the torus. Default is\n        [10, 20].\n    minor_radius_range : list of int, optional\n        Range of lengths for the minor radius of the torus. Default is\n        [3, 6].\n    n_blobs : int, optional\n        Maximum number of tori to generate. Default is 10.\n    jitter : float, optional\n        Maximum amount of jitter to apply to the shape. Default is 0.5.\n    device : str, optional\n        Device to run the tensor operations ('cuda' or 'cpu'). Default is\n        'cuda'.\n    shape : int, optional\n        Size of the 3D volume (assumed to be cubic). Default is 128.\n    \"\"\"\n    super(TorusBlobBase, self).__init__()\n    self.major_radius_range = major_radius_range\n    self.minor_radius_range = minor_radius_range\n    self.jitter = cc.Uniform.make(make_range(0, jitter))\n    self.device = device\n    self.shape = [shape, shape, shape]\n    self.return_mask = return_mask\n    self.depth, self.height, self.width = self.shape\n    self.n_blobs = cc.RandInt.make(make_range(1, n_blobs))\n    self.imprint_tensor = torch.zeros(self.shape, dtype=torch.float32,\n                                      device=self.device)\n    self.current_label = 1\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobSampler.forward","title":"forward","text":"<pre><code>forward()\n</code></pre> <p>Apply torus sampling operation.</p> RETURNS DESCRIPTION <code>shapes</code> <p>Tori with unique integer labels.</p> <p> TYPE: <code>Tensor[int]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def forward(self):\n    \"\"\"\n    Apply torus sampling operation.\n\n    Returns\n    -------\n    shapes : torch.Tensor[int]\n        Tori with unique integer labels.\n    \"\"\"\n    labels = self.make_shapes()\n    if self.return_mask:\n        mask = (labels &gt; 0).bool().to(self.device)\n        return labels, mask\n    else:\n        return labels\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobAugmentation","title":"TorusBlobAugmentation","text":"<pre><code>TorusBlobAugmentation(\n    shape=128,\n    major_radius_range=[10, 20],\n    minor_radius_range=[3, 6],\n    n_blobs=cc.RandInt(10, 25),\n    jitter=cc.Uniform(0, 0.5),\n    return_mask=False,\n    alpha=cc.Uniform(0.25, 0.75),\n    intensity_shift=cc.Uniform(10, 20),\n    augmentation=None,\n    device=\"cuda\",\n)\n</code></pre> <p>               Bases: <code>TorusBlobBase</code></p> <p>A module to augment 3D data (B, C, D, H, W) by sampling and alpha-blending tori.</p> <p>Inherits from TorusBlobBase.</p> PARAMETER DESCRIPTION <code>major_radius_range</code> <p>Range of lengths for the major radius of the torus. Default is [10, 20].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[10, 20]</code> </p> <code>minor_radius_range</code> <p>Range of lengths for the minor radius of the torus. Default is [3, 6].</p> <p> TYPE: <code>list of int</code> DEFAULT: <code>[3, 6]</code> </p> <code>n_blobs</code> <p>Maximum number of tori to generate. Default is 10.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RandInt(10, 25)</code> </p> <code>jitter</code> <p>Maximum amount of jitter to apply to the shape. Default is 0.5.</p> <p> TYPE: <code>float</code> DEFAULT: <code>Uniform(0, 0.5)</code> </p> <code>device</code> <p>Device to run the tensor operations ('cuda' or 'cpu'). Default is 'cuda'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cuda'</code> </p> <code>shape</code> <p>Size of the 3D volume (assumed to be cubic). Default is 128.</p> <p> TYPE: <code>int</code> DEFAULT: <code>128</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def __init__(self,\n             shape=128,\n             major_radius_range=[10, 20],\n             minor_radius_range=[3, 6],\n             n_blobs=cc.RandInt(10, 25),\n             jitter: Sampler = cc.Uniform(0, 0.5),\n             return_mask: bool = False,\n             alpha: Sampler = cc.Uniform(0.25, 0.75),\n             intensity_shift: float = cc.Uniform(10, 20),\n             augmentation=None,\n             device='cuda',\n             ):\n    super(TorusBlobBase, self).__init__()\n    \"\"\"\n    A module to augment 3D data (B, C, D, H, W) by sampling and\n    alpha-blending tori.\n\n    Parameters\n    ----------\n    major_radius_range : list of int, optional\n        Range of lengths for the major radius of the torus. Default is\n        [10, 20].\n    minor_radius_range : list of int, optional\n        Range of lengths for the minor radius of the torus. Default is\n        [3, 6].\n    n_blobs : int, optional\n        Maximum number of tori to generate. Default is 10.\n    jitter : float, optional\n        Maximum amount of jitter to apply to the shape. Default is 0.5.\n    device : str, optional\n        Device to run the tensor operations ('cuda' or 'cpu'). Default is\n        'cuda'.\n    shape : int, optional\n        Size of the 3D volume (assumed to be cubic). Default is 128.\n    alpha : list[float, float]\n        Range of alpha magnitude for alpha blending. Default is\n        [0.25, 0.75]\n    intensity\n    return_mask : bool\n        Optionally return torus mask. Default is False\n    \"\"\"\n    self.shape = [shape, shape, shape]\n    self.major_radius_range = major_radius_range\n    self.minor_radius_range = minor_radius_range\n    self.n_blobs = cc.RandInt.make(make_range(1, n_blobs))\n    self.jitter = cc.Uniform.make(make_range(0, jitter))\n    self.return_mask = return_mask\n    self.device = device\n    self.depth, self.height, self.width = self.shape\n    self.imprint_tensor = torch.zeros(\n        self.shape, dtype=torch.float32, device=self.device\n        )\n    self.current_label = 1\n    if augmentation is None:\n        self.augmentation = cc.RandomGaussianMixtureTransform(mu=0)\n    else:\n        self.augmentation = augmentation\n\n    self.alpha = cc.Uniform.make(make_range(0.5, alpha))\n    self.intensity_shift = cc.Uniform.make(make_range(0, intensity_shift))\n    self.blender = Blender(\n        alpha=self.alpha,\n        intensity_shift=self.intensity_shift\n    )\n</code></pre>"},{"location":"api/shapes/#SynthShapes.shapes.TorusBlobAugmentation.forward","title":"forward","text":"<pre><code>forward(background_intensities)\n</code></pre> <p>Apply torus augmentation to input tensor.</p> PARAMETER DESCRIPTION <code>background_intensities</code> <p>Background tensor to augment of shape (C, D, H, W)</p> <p> TYPE: <code>Tensor[float]</code> </p> RETURNS DESCRIPTION <code>blended_tori</code> <p>Tori alpha-blended into background.</p> <p> TYPE: <code>Tensor[float]</code> </p> Source code in <code>SynthShapes/shapes.py</code> <pre><code>def forward(self, background_intensities: torch.Tensor):\n    \"\"\"\n    Apply torus augmentation to input tensor.\n\n    Parameters\n    ----------\n    background_intensities : torch.Tensor[float]\n        Background tensor to augment of shape (C, D, H, W)\n\n    Returns\n    -------\n    blended_tori : torch.Tensor[float]\n        Tori alpha-blended into background.\n    \"\"\"\n\n    incoming_shape_labels = self.make_shapes()\n    incoming_shape_mask = (incoming_shape_labels &gt; 0).bool().to(\n        self.device\n        )\n    if self.augmentation:\n        incoming_shape_labels = self.augmentation(incoming_shape_labels)\n        incoming_shape_labels[~incoming_shape_mask] = 0\n\n    blended = self.blender(\n        incoming_shape_labels.to(self.device),\n        background_intensities.to(self.device),\n        incoming_shape_mask.to(self.device)\n    )\n\n    if self.return_mask:\n        return blended, incoming_shape_mask\n    else:\n        return blended\n</code></pre>"},{"location":"api/texturizing/","title":"SynthShapes.texturizing","text":""},{"location":"api/texturizing/#SynthShapes.texturizing","title":"SynthShapes.texturizing","text":"<p>The <code>SynthShapes.texturizing</code> module provides tools for converting labeled data into textured intensity images, facilitating the creation of synthetic medical images with realistic textures.</p>"},{"location":"api/texturizing/#SynthShapes.texturizing.LabelsToIntensities","title":"LabelsToIntensities","text":"<pre><code>LabelsToIntensities(\n    mu=1, sigma=2, min=0.1, max=0.5, transform=None\n)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Convert a set of labels with unique IDs into intensities.</p> PARAMETER DESCRIPTION <code>mu</code> <p>Mean of GMM.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>sigma</code> <p>Sigma of GMM.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>min</code> <p>Minimum value of the output tensor (except background zeros)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>max</code> <p>Maximum value of output tensor.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>transform</code> <p>Single transform or moduledict</p> <p> TYPE: <code>Module</code> DEFAULT: <code>None</code> </p> Source code in <code>SynthShapes/texturizing.py</code> <pre><code>def __init__(self, mu=1, sigma=2, min=0.1, max=0.5, transform=None):\n    \"\"\"\n    Convert a set of labels with unique IDs into intensities.\n\n    Parameters\n    ----------\n    mu : float\n        Mean of GMM.\n    sigma : float\n        Sigma of GMM.\n    min : float\n        Minimum value of the output tensor (except background zeros)\n    max : float\n        Maximum value of output tensor.\n    transform : torch.nn.Module\n        Single transform or moduledict\n    \"\"\"\n    super(LabelsToIntensities, self).__init__()\n    self.mu = mu\n    self.sigma = sigma\n    self.min = min\n    self.max = max\n    if transform is None:\n        self.transform = RandomGaussianMixtureTransform(mu=1, sigma=2)\n    else:\n        self.transform = transform\n</code></pre>"},{"location":"api/texturizing/#SynthShapes.texturizing.LabelsToIntensities.forward","title":"forward","text":"<pre><code>forward(labels)\n</code></pre> <p>Apply the transformation</p> PARAMETER DESCRIPTION <code>labels</code> <p>Labels with unique int ID's. Shape: (x, y, z)</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>SynthShapes/texturizing.py</code> <pre><code>def forward(self, labels):\n    \"\"\"\n    Apply the transformation\n\n    Parameters\n    ----------\n    labels : torch.Tensor\n        Labels with unique int ID's. Shape: (x, y, z)\n    \"\"\"\n\n    # Create a mask for all labels (background = 0, labels = 1)\n    label_mask = (torch.clone(labels) != 0)\n    # Assign intensities by applying transform\n    intensities = self.transform(labels)\n    # Invert mask and zero all background values\n    intensities[~label_mask] = 0\n\n\n    return intensities\n</code></pre>"},{"location":"api/texturizing/#SynthShapes.texturizing.TexturizeLabels","title":"TexturizeLabels","text":"<pre><code>TexturizeLabels(sigma=2, intensity=1, transform=None)\n</code></pre> <p>               Bases: <code>Module</code></p> PARAMETER DESCRIPTION <code>sigma</code> <p>Standard deviation for label textures.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>intensity</code> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> Source code in <code>SynthShapes/texturizing.py</code> <pre><code>def __init__(self, sigma: float = 2, intensity: float = 1,\n             transform=None):\n    \"\"\"\n    Parameters\n    ----------\n    sigma: Sampler or float\n        Standard deviation for label textures.\n    intensity \n    \"\"\"\n    super(TexturizeLabels, self).__init__()\n    self.sigma = cc.Uniform.make(make_range(0, sigma))\n    self.intensity = cc.Uniform.make(make_range(0, intensity))\n    if transform is None:\n        self.transform = torch.nn.Sequential(\n            cc.RandomGaussianMixtureTransform(sigma=self.sigma),\n            cc.RandomGammaNoiseTransform(),\n            cc.MulFieldTransform(vmin=0.1, vmax=0.75)\n            )\n    else:\n        self.transform = transform\n</code></pre>"},{"location":"api/texturizing/#SynthShapes.texturizing.ParenchymaSynthesizer","title":"ParenchymaSynthesizer","text":"<pre><code>ParenchymaSynthesizer()\n</code></pre> <p>               Bases: <code>Module</code></p> <p>A torch.nn.Module subclass that synthesizes a background tensor by applying a series of transformations.</p> Source code in <code>SynthShapes/texturizing.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    A torch.nn.Module subclass that synthesizes a background tensor\n    by applying a series of transformations.\n    \"\"\"\n    super(ParenchymaSynthesizer, self).__init__()\n\n    # Define the transformations to be applied sequentially\n    self.parenchyma_transform = torch.nn.Sequential(\n        cc.RandomGaussianMixtureTransform(mu=1, sigma=2),\n        MinMaxScaler(),\n        cc.RandomGammaNoiseTransform(),\n        MinMaxScaler(),\n        cc.MulFieldTransform(vmin=0.1, vmax=0.75),\n        MinMaxScaler(),\n    )\n\n    # Define the final quantile transform\n    self.quantile_transform = cc.QuantileTransform()\n\n    # Define the blender\n    self.blender = Blender()\n\n    # Define the initial smooth label map generator\n    self.random_smooth_label_map = cc.RandomSmoothLabelMap()\n\n    # Final MinMaxScaler to normalize the background\n    self.final_scaler = MinMaxScaler()\n</code></pre>"},{"location":"api/texturizing/#SynthShapes.texturizing.ParenchymaSynthesizer.forward","title":"forward","text":"<pre><code>forward(intensities_list, alpha=0.4)\n</code></pre> <p>Synthesizes the background by applying the defined transformations and blending multiple intensity tensors.</p> PARAMETER DESCRIPTION <code>intensities_list</code> <p>A list of tensors with intensities to blend into the background.</p> <p> TYPE: <code>list of torch.Tensor</code> </p> <code>alpha</code> <p>The blending parameter controlling the influence of intensities in the background.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.4</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>The synthesized background tensor.</p> Source code in <code>SynthShapes/texturizing.py</code> <pre><code>def forward(self, intensities_list: list, alpha: float = 0.4\n            ) -&gt; torch.Tensor:\n    \"\"\"\n    Synthesizes the background by applying the defined transformations\n    and blending multiple intensity tensors.\n\n    Parameters\n    ----------\n    intensities_list : list of torch.Tensor\n        A list of tensors with intensities to blend into the background.\n    alpha : float\n        The blending parameter controlling the influence of intensities in\n        the background.\n\n    Returns\n    -------\n    torch.Tensor\n        The synthesized background tensor.\n    \"\"\"\n    # Initialize the parenchyma tensor with ones and apply the smooth\n    # label map.\n    # Assuming all tensors are on same device.\n    device = intensities_list[0].device\n    parenchyma = torch.ones_like(intensities_list[0]).to(device)\n    parenchyma = self.random_smooth_label_map(parenchyma)\n    parenchyma += 1\n\n    # Apply the sequential transformations\n    parenchyma = self.parenchyma_transform(parenchyma)\n\n    # Blend each intensity tensor in the list with the parenchyma\n    for intensities in intensities_list:\n        parenchyma = self.blender(\n            foreground=intensities,\n            background=parenchyma,\n            mask=(intensities &gt; 0).bool(),\n            alpha=alpha)\n\n    # Apply final scaling and quantile transform\n    parenchyma = self.final_scaler(parenchyma)\n    parenchyma = self.quantile_transform(parenchyma)\n\n    return parenchyma\n</code></pre>"},{"location":"api/utils/","title":"Utils","text":""},{"location":"api/utils/#SynthShapes.utils","title":"SynthShapes.utils","text":""},{"location":"api/utils/#SynthShapes.utils.MinMaxScaler","title":"MinMaxScaler","text":"<pre><code>MinMaxScaler(lower_bound=0.01, upper_bound=0.99)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>A torch.nn.Module subclass that scales an input tensor to a specified range.</p> PARAMETER DESCRIPTION <code>lower_bound</code> <p>The lower bound of the scaling interval. Default is 0.1.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> <code>upper_bound</code> <p>The upper bound of the scaling interval. Default is 0.9.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.99</code> </p> Source code in <code>SynthShapes/utils.py</code> <pre><code>def __init__(self, lower_bound: float = 0.01, upper_bound: float = 0.99):\n    \"\"\"\n    A torch.nn.Module subclass that scales an input tensor to a specified\n    range.\n\n    Parameters\n    ----------\n    lower_bound : float\n        The lower bound of the scaling interval. Default is 0.1.\n    upper_bound : float\n        The upper bound of the scaling interval. Default is 0.9.\n    \"\"\"\n    super(MinMaxScaler, self).__init__()\n    self.lower_bound = lower_bound\n    self.upper_bound = upper_bound\n</code></pre>"},{"location":"api/utils/#SynthShapes.utils.MinMaxScaler.forward","title":"forward","text":"<pre><code>forward(X)\n</code></pre> <p>Forward pass to scale the input tensor X to the interval [lower_bound, upper_bound].</p> PARAMETER DESCRIPTION <code>X</code> <p>Input tensor with arbitrary floating point values.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>Scaled tensor with values in the interval [lower_bound, upper_bound].</p> Source code in <code>SynthShapes/utils.py</code> <pre><code>def forward(self, X: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Forward pass to scale the input tensor X to the interval\n    [lower_bound, upper_bound].\n\n    Parameters\n    ----------\n    X : torch.Tensor\n        Input tensor with arbitrary floating point values.\n\n    Returns\n    -------\n    torch.Tensor\n        Scaled tensor with values in the interval\n        [lower_bound, upper_bound].\n    \"\"\"\n    X_min = X.min()\n    X_max = X.max()\n\n    # Prevent division by zero if X_min == X_max\n    if X_min == X_max:\n        return torch.full_like(X, self.lower_bound)\n\n    # Scale the tensor to the range [lower_bound, upper_bound]\n    X_scaled = self.lower_bound + (X - X_min) * (\n        self.upper_bound - self.lower_bound) / (X_max - X_min)\n\n    return X_scaled\n</code></pre>"},{"location":"api/utils/#SynthShapes.utils.ensure_5d_tensor","title":"ensure_5d_tensor","text":"<pre><code>ensure_5d_tensor(volume)\n</code></pre> <p>Ensures the input tensor has 5 dimensions [batch_size, channels, depth, height, width].</p> PARAMETER DESCRIPTION <code>volume</code> <p>Input tensor representing the volume.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>Tensor with 5 dimensions.</p> Source code in <code>SynthShapes/utils.py</code> <pre><code>def ensure_5d_tensor(volume: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Ensures the input tensor has 5 dimensions [batch_size, channels, depth,\n    height, width].\n\n    Parameters\n    ----------\n    volume : torch.Tensor\n        Input tensor representing the volume.\n\n    Returns\n    -------\n    torch.Tensor\n        Tensor with 5 dimensions.\n    \"\"\"\n    if volume.dim() == 3:  # (D, H, W)\n        # Add batch and channel dimensions\n        volume = volume.unsqueeze(0).unsqueeze(0)\n    elif volume.dim() == 4:  # (C, D, H, W)\n        # Add batch dimension\n        volume = volume.unsqueeze(0)\n\n    return volume\n</code></pre>"}]}